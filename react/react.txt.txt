===> React Installtion :- npx create-react-app ./

===> React Project Live Command :- npm start

===> React Routing :- npm i react-router-dom 

==> useState :-  useState return array With 2 Value. ==> 1st.Value Current State Value and 2nd.Updated Value . and render components and pages

===========================================================

==> useEffect:- useEffect is allows to perform side effect in components.side Effect likes ==> fetch Data from Api,directly Updating DOM,timers.useEffect work on 3 ways.(1)without dependency work on every render (2)with Empty dependency
		one time work (3)with dependency working on when updated value change in state  

========================================================

==> useContext:- globally state manage .. props drilling breaks.

step(1)create new context file with .js extension. in file create context import karvano.then export karvano.UserContext Variable name

ex. ==> import { createContext } from "react";
	export const MyContext = createContext()

(2) je components ma use karvano tya import karvano.

(3)app.js ma globally state create karva no.Context Create wali file import karva ni pachi Context ne Wrap Karvano ane teno provider banava no. ane value pass karva ni . always name value={name} hovu joi ee.
		
	 <MyContext.Provider value={value}>
      <Routes>
        <Route path="/" element={<Student  student={studentData}/>}/>
        <Route path="/state" element={<State/>}/>
        <Route path="/effect" element={<Effect/>}/>
        <Route path="/comp1" element={<Components1/>}/>
        <Route path="/comp2" element={<Components2/>}/>
      </Routes>
      </MyContext.Provider>

(4) je components ma context use karva no ee components ma context import karva no.pachi create one variable store in useContext(je Context Create karo hoi tenu name:MyContext) 

==========================================================

===> useRef : The useRef Hook allows you to persist values between renders.
	      It can be used to store a mutable value that does not cause a re-render when updated.
              It can be used to access a DOM element directly.

==========================================================

====> useReducer : The useReducer Hook is similar to the useState Hook.
		   It allows for custom state logic.
                   
                   The reducer function contains your custom state logic and the initialStatecan be a simple value but generally will contain an object.
                   The useReducer Hook returns the current state and a dispatch method.

		   useReducer Returns ==> An array with exactly two values:
 
                   (1)The current state. During the first render, it’s set to init(initialArg) or initialArg (if there’s no init).
		   (2)The dispatch function that lets you update the state to a different value and trigger a re-render.


=======  syntax  ======

import { useReducer } from 'react';

function reducer(state, action) {
  // ...  logic //
}

function MyComponent() {
  const [state, dispatch] = useReducer(reducer, { age: 42 });
  // ...  ///

//dispatch Function //
function handleClick() {
  dispatch({ type: 'incremented_age' });
  // ...

=========================================================== 

====> useCallBack :=	
		    The React useCallback Hook returns a memoized callback function.

========================================================

====> useMemo :=
		 The React useMemo Hook returns a memoized value. (epensive value counting mate use  like== 10000000000)
		 without useMemo return Output given delay..
				
========================================================

===> Create Custom Hooks :=
		
( == Steps === )

==> useForm Custom Hooks :-
create 2 File Example Like : (1) useForm.js (2) any fileName.jsx (InputForm.jsx) but je file custom hook ni hoi ee file nu name small letter thi rakhvu. like use..any

useForm File ma Logic Avse and second ma Ui and Code

=======================================================

====> useLayoutEffect :== The useLayoutEffect hook is similar to useEffect, but it’s executed synchronously after all DOM mutations. This makes it useful for manipulating the DOM immediately after a component is rendered.

main width = clientWidth
main height = clientHeight

import React, { useState, useLayoutEffect, useRef } from 'react';

function ResizableBox() {
  const [width, setWidth] = useState(100);
  const [height, setHeight] = useState(100);
  const boxRef = useRef(null);

  useLayoutEffect(() => {
    const handleResize = () => {
      setWidth(boxRef.current.clientWidth);
      setHeight(boxRef.current.clientHeight);
    };

    handleResize();

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return (
    <div ref={boxRef} style={{ width: '50%', height: '50%', backgroundColor: 'red' }}>
      <p>Width: {width}px</p>
      <p>Height: {height}px</p>
    </div>
  );
}












